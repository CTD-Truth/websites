{"id":1271,"date":"2021-08-21T11:22:04","date_gmt":"2021-08-21T15:22:04","guid":{"rendered":"https:\/\/learn.codethedream.org\/?page_id=1271"},"modified":"2022-01-29T17:56:27","modified_gmt":"2022-01-29T22:56:27","slug":"more-rest-apis","status":"publish","type":"page","link":"https:\/\/learn.codethedream.org\/more-rest-apis\/","title":{"rendered":"More REST APIs"},"content":{"rendered":"\n<p>In the previous part of the lesson, we implemented REST authentication using JWT tokens.  Of course, when building an API, you do more than authenticate.  In this part of the lesson we will add some additional APIs for CRUD operations.  Create a new branch called more-rest for this part of the assignment.<\/p>\n\n\n\n<h2>Models<\/h2>\n\n\n\n<p>First, create your models.  WIthin the repository directory, you do the following commands:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails generate model Member first_name:string last_name:string\nbin\/rails generate model Fact member:references fact_text:string likes:integer<\/code><\/pre>\n\n\n\n<p>There is a one-to-many relationship between member and facts.  Next you edit the model files.  The file app\/models\/member.rb should look like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>class Member &lt; ApplicationRecord\n  validates :first_name, presence: true\n  validates :last_name, presence: true\n  has_many :facts\nend<\/code><\/pre>\n\n\n\n<p>And app\/models\/fact.rb should look like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>class Fact &lt; ApplicationRecord\n  validates :fact_text, presence: true\n  validates :likes, presence: true\n  validates :member_id, presence: true\n  validates_associated :member\n  belongs_to :member\nend<\/code><\/pre>\n\n\n\n<p>Note that you have validations, just as in Rails UI applications with views.  Next, you set up the development and test databases as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails db:migrate\nbin\/rails db:migrate RAILS_ENV=test<\/code><\/pre>\n\n\n\n<h2>Controllers<\/h2>\n\n\n\n<p>Now, you set up your controllers.  We are going to set them up with a route namespace, that includes a version number for the API.  This is best practice, as your API may change over time.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails g controller api\/v1\/Members\nbin\/rails g controller api\/v1\/Facts<\/code><\/pre>\n\n\n\n<p>Next you set up your routes.  You should add the following section to yourconfig\/routes.rb file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  namespace :api do\n    namespace :v1 do\n      resources :members do\n        resources :facts\n      end\n    end\n  end<\/code><\/pre>\n\n\n\n<p>These routes are similar to what you have used before, with the exception that you are using route namespaces to separate them out.  The routes for facts are nested within the member routes, corresponding to the one-to-many association between members and facts.<\/p>\n\n\n\n<h2>Adding Application Logic<\/h2>\n\n\n\n<p>Your application logic goes in your controllers.  Because this is an API, there are no files corresponding to views.  When a request comes in, the response will always render json, to send the responses in json format back to the caller.  In other respects, the processing is much as in Rails UI applications.  The HTTP status code returned will be, by default, 200, but there are other status codes that are appropriate sometimes.  For example, 201 means resource created, and the 400 series codes imply a client side error.  We will require authentication for access to these controller operations, so we need to include AuthenticationCheck and call is_user_logged_in. This is an unfinished version of your app\/controllers\/api\/v1\/members_controller.rb file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>class Api::V1::MembersController &lt; ApplicationController\n  include AuthenticationCheck\n\n  before_action :is_user_logged_in\n  before_action :set_member, only: &#91;:show, :update, :destroy]\n\n  # GET \/members\n  def index\n    @members = Member.all\n    render json: @members\n  end\n\n  # GET \/members\/:id\n  def show\n    # your code goes here\n  end\n\n  # POST \/members\n  def create\n    @member = Member.new(member_params)\n    if @member.save\n      render json: @member, status: 201\n    else\n      render json: { error:\n        \"Unable to create member: #{@member.errors.full_messages.to_sentence}\"},\n        status: 400\n    end\n  end\n\n  # PUT \/members\/:id\n  def update\n    # your code godes here\n  end\n\n  # DELETE \/members\/:id\n  def destroy\n    @member.destroy\n    render json: { message: 'Member record successfully deleted.'}, status: 200\n  end\n\n  private\n\n  def member_params\n    params.require(:member).permit(:first_name, :last_name)\n  end\n\n  def set_member\n    @member = Member.find(params&#91;:id])\n  end\n\nend<\/code><\/pre>\n\n\n\n<p>You will have to complete the update and show methods yourself..  Include error handling!  For the app\/controllers\/api\/v1\/facts_controller.rb file, you can use the following outline, but most of the methods you will have to complete yourself.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>class Api::V1::FactsController &lt; ApplicationController\n  include AuthenticationCheck\n\n  before_action :is_user_logged_in\n  before_action :set_fact, only: &#91;:show, :update, :destroy]\n\n  # GET \/members\/:member_id\/facts\n  def index\n    @member = Member.find(params&#91;:member_id])\n    render json: @member.facts # note that because the facts route is nested inside members\n                             # we return only the facts belonging to that member\n  end\n\n  # GET \/members\/:member_id\/facts\/:id\n  def show\n    # your code goes here\n  end\n\n  # POST \/members\/:member_id\/facts\n  def create\n     @member = Member.find(params&#91;:member_id])\n    @fact = @member.facts.new(fact_params)\n    if @fact.save\n      render json: @fact, status: 201\n    else\n      render json: { error: \n\"The fact entry could not be created. #{@fact.errors.full_messages.to_sentence}\"},\n      status: 400\n    end\n  end\n\n  # PUT \/members\/:member_id\/facts\/:id\n  def update\n    # your code goes here\n  end\n\n  # DELETE \/members\/:member_id\/facts\/:id\n  def destroy\n    # your code goes here\n  end\n\n  private\n\n  def fact_params\n    params.require(:fact).permit(:fact_text, :likes)\n  end\n\n  def set_fact\n    @fact = Fact.find(params&#91;:id])\n  end\n\nend<\/code><\/pre>\n\n\n\n<h2>Exception Handling<\/h2>\n\n\n\n<p>The client application may send some bad json, or specify the id of a user or fact that does not exist.  You need to catch those errors and return an appropriate error message and HTTP result code to the calling client application.  This is done by creating an exception handler module, which is app\/controllers\/concerns\/exception_handler.rb:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># app\/controllers\/concerns\/exception_handler.rb\nmodule ExceptionHandler\n  # provides the more graceful `included` method\n  extend ActiveSupport::Concern\n\n  included do\n    rescue_from ActiveRecord::RecordNotFound do |e|\n      render json: { error: e.message }, status: :not_found\n    end\n\n    rescue_from ActiveRecord::RecordInvalid do |e|\n      render json: { error: e.message }, status: :unprocessable_entity\n    end\n\n    rescue_from ActionController::ParameterMissing do |e|\n      render json: { error: e.message }, status: :unprocessable_entity\n    end\n  end\nend\n<\/code><\/pre>\n\n\n\n<p>Then add this line to app\/controllers\/application_controller.rb, just before the end statement:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  include ExceptionHandler<\/code><\/pre>\n\n\n\n<h2>Testing Your Code Using Curl<\/h2>\n\n\n\n<p>The curl tool will send json to the URL you specify, and will also report back the json it receives.  You can send the following commands, to see what happens.  First, start the server using <\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails s <\/code><\/pre>\n\n\n\n<p>And then try REST requests to that server, using curl.  You will need a second command line for this.  If you are running vagrant, that is another git bash session in which you have run vagrant ssh.  Note that we need authentication, so we pass as a header the contents of authheader.txt, which was created in the previous part of the lesson.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>curl -XGET -H @authheader.txt -H \"Content-Type: application\/json\" http:\/\/localhost:3000\/api\/v1\/members\n\ncurl -XPOST -H @authheader.txt -H \"Content-Type: application\/json\" -d '{ \"first_name\": \"Fred\", \"last_name\": \"James\" }' http:\/\/localhost:3000\/api\/v1\/members\n\ncurl -XPOST -H @authheader.txt -H \"Content-Type: application\/json\" -d '{ \"first_name\": \"Mary\", \"last_name\": \"Jones\" }' http:\/\/localhost:3000\/api\/v1\/members\n\ncurl -XGET -H @authheader.txt -H \"Content-Type: application\/json\" http:\/\/localhost:3000\/api\/v1\/members\n\ncurl -XGET -H @authheader.txt -H \"Content-Type: application\/json\" http:\/\/localhost:3000\/api\/v1\/members\/1\n\ncurl -XPOST -H @authheader.txt -H \"Content-Type: application\/json\" -d '{ \"fact_text\": \"This is a new fact.\", \"likes\": 6 }' http:\/\/localhost:3000\/api\/v1\/members\/1\/facts\n\ncurl -XGET -H @authheader.txt -H \"Content-Type: application\/json\" http:\/\/localhost:3000\/api\/v1\/members\/1\/facts<\/code><\/pre>\n\n\n\n<p>You should try PUT and DELETE requests as well.  In the above, you may not have a member with id 1, so you would have to change 1 to the id of some member you do have.  You should also try a curl command without sending authheader..txt, to see that you get a message back that you are not authenticated.<\/p>\n\n\n\n<p>Once you get this far, stop the server, commit your changes, push them to github, and open a pull request.  We will do the next steps in a new branch called swagger.  After you have pushed your changes, while the more-rest branch is active, create a swagger branch from the more-rest branch.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>In the previous part of the lesson, we implemented REST authentication using JWT tokens. Of course, when building an API, you do more than authenticate. In this part of the lesson we will add some additional APIs for CRUD operations. Create a new branch called more-rest for this part of the assignment. Models First, create<\/p>\n","protected":false},"author":5,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":"","_vp_format_video_url":"","_vp_image_focal_point":[]},"featured_image_src":null,"featured_image_src_square":null,"_links":{"self":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1271"}],"collection":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/users\/5"}],"replies":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/comments?post=1271"}],"version-history":[{"count":0,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1271\/revisions"}],"wp:attachment":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/media?parent=1271"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}