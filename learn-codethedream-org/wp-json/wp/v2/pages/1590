{"id":1590,"date":"2022-04-10T21:00:19","date_gmt":"2022-04-11T01:00:19","guid":{"rendered":"https:\/\/learn.codethedream.org\/?page_id=1590"},"modified":"2022-09-04T21:08:40","modified_gmt":"2022-09-05T01:08:40","slug":"ctd-node-express-class-lesson-a-server-side-rendering-with-ejs","status":"publish","type":"page","link":"https:\/\/learn.codethedream.org\/ctd-node-express-class-lesson-a-server-side-rendering-with-ejs\/","title":{"rendered":"CTD Node\/Express Class Lesson 12: Server Side Rendering with EJS"},"content":{"rendered":"\n<h2><strong>Lesson Materials<\/strong><\/h2>\n\n\n\n<p>In this lesson, you learn EJS, a templating language for Express.  The templates contain embedded JavaScript, which is executed on the server side.  This constructs an ordinary HTML page, but with dynamic content.  Because the embedded JavaScript runs on the server, before the page is sent to the client, dynamic content can be delivered, such as information from a database.  This is called server side rendering.  Except for the embedded JavaScript, the templates are ordinary HTML pages, which may be combined with CSS and client side JavaScript.<\/p>\n\n\n\n<p>Server side rendering is in some respects easier than writing first an API and then a front end for it, where the front end makes fetch calls to the API.  On the other hand, if you don&#8217;t create an API, you can&#8217;t access the data via React or other front ends that run outside the application itself.<\/p>\n\n\n\n<p>In EJS, there are really only three kinds of embedded JavaScript statements:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;%- include 'filename' %&gt;\n&lt;% code %&gt;\n&lt;%= code %&gt;<\/code><\/pre>\n\n\n\n<p>All are encased in the &lt;% %&gt; sequence.  The one with the minus in front does an include of another template, so that you can have headers, footers, and other partials.  The one with no minus or equals sign executes code but does not return any change to the HTML.  This is used for logic statements, such as if statements and loops.  The one with the equals sign executes code and returns the result in line as HTML.<\/p>\n\n\n\n<h2><strong>Assignments<\/strong><\/h2>\n\n\n\n<p><strong>Coding Assignment<\/strong><\/p>\n\n\n\n<p>Create an ejs-demo directory.  This should not be inside the node-express-course directory, but it should be in the same directory where the node-express-course directory resides. Go to the following link and follow the instructions: <a rel=\"noreferrer noopener\" href=\"https:\/\/www.digitalocean.com\/community\/tutorials\/how-to-use-ejs-to-template-your-node-application\" target=\"_blank\">https:\/\/www.digitalocean.com\/community\/tutorials\/how-to-use-ejs-to-template-your-node-application<\/a> .  This creates a working application that you should test by opening it with your browser, at localhost:8080.<\/p>\n\n\n\n<h2>Saving Your Work to Github<\/h2>\n\n\n\n<p>This assignment did not begin with a starter git repository.  You must create a new one to be able to submit your work.  Within the ejs-demo directory, type the following terminal commands:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>cp ..\/node-express-course\/03-task-manager\/starter\/.gitignore .\ngit init\ngit add -A\ngit commit -m \"first commit\"<\/code><\/pre>\n\n\n\n<p>Sign in to github and create a new repository called ejs-demo.  You do this using the plus icon in the upper right of the screen.  It should be a public repository.  Do not create a gitignore, README, or license.  This then shows you a screen including a section that looks like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>git remote add origin https:\/\/github.com\/&lt;your-git-id&gt;\/ejs-demo.git\ngit branch -M main\ngit push -u origin main<\/code><\/pre>\n\n\n\n<p>except it has your git id in the origin line.  Execute each of these commands in your terminal.  This creates your github repository and stores the code in it.<\/p>\n\n\n\n<p>&#8230; But we are just getting started.<\/p>\n\n\n\n<h2>Adding Code to Do CRUD Operations with MongoDB<\/h2>\n\n\n\n<p>Now you add the code to the ejs-demo application to do database operations, using the task manager database from a previous lesson.  Do the following commands:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>cp ..\/node-express-course\/03-task-manager\/starter\/.env .\ncp -r ..\/node-express-course\/03-task-manager\/starter\/db .\/db\ncp -r ..\/node-express-course\/03-task-manager\/starter\/models .\/models\nnpm install mongoose\nnpm install dotenv\nnpm install express-session\nnpm install nodemon --save-dev<\/code><\/pre>\n\n\n\n<p>Edit the db\/connect.js file, which was copied from the earlier project.  Mongoose has changed, so some of the options used in that file no longer work.  It should read as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const mongoose = require('mongoose')\n\nconst connectDB = (url) =&gt; {\n  return mongoose.connect(url)\n}\n\nmodule.exports = connectDB<\/code><\/pre>\n\n\n\n<p>Edit the .env file, to add a line like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>SESSION_SECRET=q98rpok90845okseutw<\/code><\/pre>\n\n\n\n<p>It is not critical what value you use for the session secret, except that it should be a long difficult to guess string.  Then edit the package.json file, and add lines to the script stanza, so that it looks like this:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code> \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",\n    \"start\": \"node server\",\n    \"dev\": \"nodemon server\"\n  },<\/code><\/pre>\n\n\n\n<p>Once you have done this, you can do npm start to start the server, but you can also do npm run dev to start the server under nodemon, so that it will automatically restart when you make code changes.  You have copied the .env file from the 03-task-manager project, and this contains the MONGO_URI.   You have also copied the db directory, which has code to connect to the database.  You also need to set up a session, for reasons described further on in this lesson. To get those loaded in, add the following lines to the top of server.js:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require('dotenv').config()\nconst connectDB = require('.\/db\/connect')\nconst session = require('express-session')<\/code><\/pre>\n\n\n\n<p>You now fix the startup sequence to automatically connect to the database.  In server.js, replace these lines at the bottom of the file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.listen(8080);\nconsole.log('Server is listening on port 8080');<\/code><\/pre>\n\n\n\n<p>with these:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const port = 8080;\nconst start = async () =&gt; {\n  try {\n    await connectDB(process.env.MONGO_URI);\n    app.listen(port, () =&gt;\n      console.log(`Server is listening on port ${port}...`)\n    );\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nstart()<\/code><\/pre>\n\n\n\n<p>At this point, you may want to start the server and make sure it still works.  The only real change is that you are connecting to the database.<\/p>\n\n\n\n<h2>Adding Routes, Controllers, and Middleware<\/h2>\n\n\n\n<p>Under the ejs-demo directory, create a routes directory, a middleware directory, and a controllers directory.  Within the middleware directory, create a message.js file with the following contents:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const setMessage = (req, res, next) =&gt; {\n    if (req.session.pendingMessage) {\n       res.locals.message = req.session.pendingMessage\n    } else {\n        res.locals.message = ''\n    }\n    req.session.pendingMessage = ''\n    next()\n}\n\nmodule.exports = setMessage<\/code><\/pre>\n\n\n\n<p>This is to provide a means of giving the user a message about the results of CRUD operations.  We use middleware to make sure the message is shown exactly once.  The value of the message is retrieved from the session.  Sessions are a complicated topic, but each separate user accessing the application has a separate session.  The message has to be available after a redirect, which means that the browser sends another request before the message is displayed, and the message can&#8217;t be kept in plain memory, otherwise one user might get a message intended for another. The value of the message is set into res.locals.message so that it is available via the variable &#8220;message&#8221; in each of the .ejs files &#8212; there is no need to pass the message variable on the render call.<\/p>\n\n\n\n<p>Within the routes directory, create a file tasks.js with the following contents:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const express = require('express')\n\nconst router = express.Router()\nconst {\n    addTask,\n    createTask,\n    deleteTask,\n    getTasks,\n    updateTask,\n    editTask\n} = require('..\/controllers\/tasks')\n\nrouter.route('\/').post(createTask).get(getTasks)\nrouter.route('\/edit\/:id').get(editTask)\nrouter.route('\/delete\/:id').get(deleteTask)\nrouter.route('\/update\/:id').post(updateTask)\nrouter.route('\/add').get(addTask)\n\nmodule.exports = router<\/code><\/pre>\n\n\n\n<p>Note that we use only get and post operations.  These operations are to be performed by the browser.  A browser can&#8217;t send delete, put, or patch operations.<\/p>\n\n\n\n<p>Next, create a file also called tasks.js inside the controller directory, with the following contents:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const Task = require('..\/models\/Task')\n\nconst addTask = (req, res) =&gt; {\n    res.send(\"in addTask\")\n}\n\nconst createTask = async (req, res) =&gt; {\n     res.send(\"in createTask\")\n}\n\nconst deleteTask = async (req, res) =&gt; {\n\n    res.send(\"in deleteTask\")\n}\n\nconst editTask = async (req, res) =&gt; {\n\n    res.send(\"in editTask\")\n}\n\nconst updateTask = async (req, res) =&gt; {\n\n   res.send(\"in updateTask\")\n}\n\nconst getTasks = async (req, res) =&gt; {\n\n    res.send(\"in getTasks\")\n}\n\nmodule.exports = {\n    addTask,\n    createTask,\n    deleteTask,\n    updateTask,\n    editTask,\n    getTasks\n}<\/code><\/pre>\n\n\n\n<p>Now we change the server.js to load the routes and middleware, by adding some lines.  Add these lines at the top of the file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const taskRouter = require('.\/routes\/tasks')\nconst setMessage = require('.\/middleware\/message')<\/code><\/pre>\n\n\n\n<p>Then add these lines after the line that sets the view engine to ejs:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.use(session({ secret: process.env.SESSION_SECRET, resave: false, saveUninitialized: true }));\napp.use(express.urlencoded({extended: false}))\napp.use('\/tasks', setMessage, taskRouter)<\/code><\/pre>\n\n\n\n<p>FIrst you set up the session.  Then, the express.urlencoded line invokes express middleware to parse the data that is returned when the browser posts form results.  The next line invokes the message middleware and the routes you created.<\/p>\n\n\n\n<p>You should now test the following routes using the browser:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>localhost:8080\/tasks\nlocalhost:8080\/tasks\/add\nlocalhost:8080\/tasks\/delete\/123\nlocalhost:8080\/tasks\/edit\/123<\/code><\/pre>\n\n\n\n<p>You can&#8217;t test the post routes, because you need to create forms to do the posts.  But now we need some views.<\/p>\n\n\n\n<h2>Creating Templates for Views<\/h2>\n\n\n\n<p>In the views\/pages directory, create a file tasks.ejs with the following contents:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;%- include('..\/partials\/head'); %&gt;\n&lt;\/head&gt;\n&lt;body class=\"container\"&gt;\n\n&lt;header&gt;\n  &lt;%- include('..\/partials\/header'); %&gt;\n&lt;\/header&gt;\n\n&lt;main&gt;\n  &lt;p&gt;&lt;%= message %&gt;&lt;\/p&gt;\n  &lt;div class=\"jumbotron\"&gt;\n    &lt;% if (tasks.length &gt; 0) { %&gt;\n      &lt;table class=\"table\"\n        &lt;tr&gt;&lt;th&gt;Name&lt;\/th&gt;&lt;th&gt;Completed&lt;\/th&gt;&lt;th colspan=\"2\"&gt;&lt;\/th&gt;&lt;\/tr&gt;\n        &lt;% tasks.forEach(function(task){ %&gt;\n          &lt;tr&gt;&lt;td&gt;&lt;%= task.name %&gt;&lt;\/td&gt;&lt;td&gt;&lt;%= task.completed %&gt;&lt;\/td&gt;\n            &lt;td&gt;&lt;a href=&lt;%= \"\/tasks\/edit\/\" + task.id %&gt;  class=\"btn btn-primary\"&gt;Edit&lt;\/a&gt;&lt;\/td&gt;\n            &lt;td&gt;&lt;a href=&lt;%= \"\/tasks\/delete\/\" + task.id %&gt;  class=\"btn btn-primary\"&gt;Delete&lt;\/a&gt;&lt;\/td&gt;\n          &lt;\/tr&gt;\n        &lt;% }) %&gt;\n      &lt;\/table&gt;\n    &lt;% } else { %&gt;\n      &lt;h2&gt;There are no tasks to display.&lt;\/h2&gt;\n    &lt;% } %&gt;\n    &lt;a href=\"\/tasks\/add\" class=\"btn btn-primary\"&gt;Add a Task&lt;\/a&gt;\n  &lt;\/div&gt;\n&lt;\/main&gt;\n\n&lt;footer&gt;\n  &lt;%- include('..\/partials\/footer'); %&gt;\n&lt;\/footer&gt;\n\n&lt;\/body&gt;\n&lt;\/html&gt;<\/code><\/pre>\n\n\n\n<p>Take a close look at the file above to make sure you understand it.  There is embedded JavaScript that references a variable called message, and displays the result in a paragraph.  There is embedded JavaScript that checks the tasks variable.  This is an array of tasks.  If the array is empty, there are no tasks in the database, so a message is shown.  If the array is not empty a loop is executed, and a row is added for each task.  Each row has an edit button and a delete button, which are links styled as buttons.  Note that the links include the ID of the task entry, so that the controller knows which task to edit or delete.<\/p>\n\n\n\n<p>Next, create the template for adding a task.  Create a file views\/pages\/addTask.ejs, with the following contents.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n  &lt;%- include('..\/partials\/head'); %&gt;\n&lt;\/head&gt;\n&lt;body class=\"container\"&gt;\n\n&lt;header&gt;\n  &lt;%- include('..\/partials\/header'); %&gt;\n&lt;\/header&gt;\n\n&lt;main&gt;\n  &lt;p&gt;&lt;%= message %&gt;&lt;\/p&gt;\n&lt;form action=\"\/tasks\" method=\"post\"&gt;\n  &lt;label for=\"name\"&gt;Name:&lt;\/label&gt;&lt;br&gt;\n  &lt;input name=\"name\"&gt;&lt;br&gt;\n  &lt;label for=\"complete\"&gt;Completed: &lt;\/label&gt;\n  &lt;input type=\"checkbox\" name=\"complete\" value=\"true\"&gt;&lt;br&gt;&lt;br&gt;\n  &lt;button type=\"submit\"&gt;Add&lt;\/button&gt;\n&lt;\/form&gt;\n  &lt;\/div&gt;\n&lt;\/main&gt;\n\n&lt;footer&gt;\n  &lt;%- include('..\/partials\/footer'); %&gt;\n&lt;\/footer&gt;\n\n&lt;\/body&gt;\n&lt;\/html&gt;<\/code><\/pre>\n\n\n\n<p>This is simpler.  It is a straightforward form with a submit button.  There isn&#8217;t a lot of embedded JavaScript except for the includes and the message.  However, for edit, you have to prepopulate the form with the values from an existing task, so that&#8217;s more complicated.  Create a file views\/pages\/editTask.ejs with the following contents.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;!DOCTYPE html>\n&lt;html lang=\"en\">\n\n&lt;head>\n  &lt;%- include('..\/partials\/head'); %>\n&lt;\/head>\n\n&lt;body class=\"container\">\n\n  &lt;header>\n    &lt;%- include('..\/partials\/header'); %>\n  &lt;\/header>\n\n  &lt;main>\n    &lt;p>\n      &lt;%= message %>\n    &lt;\/p>\n    &lt;form action=&lt;%= \"\/tasks\/update\/\" + task.id %> method=\"post\">\n      &lt;label for=\"name\">Name:&lt;\/label> &lt;br>\n      &lt;input name=\"name\" value=\"&lt;%=task.name %>\">&lt;br>\n      &lt;label for=\"complete\">Completed: &lt;\/label>\n      &lt;% if (task.completed) { %>\n        &lt;input type=\"checkbox\" name=\"complete\" value=\"true\" checked>&lt;br>&lt;br>\n        &lt;% } else { %>\n          &lt;input type=\"checkbox\" name=\"complete\" value=\"false\">&lt;br>&lt;br>\n          &lt;% } %>\n            &lt;button type=\"submit\">Update&lt;\/button>\n    &lt;\/form>\n    &lt;\/div>\n  &lt;\/main>\n\n  &lt;footer>\n    &lt;%- include('..\/partials\/footer'); %>\n  &lt;\/footer>\n\n&lt;\/body>\n\n&lt;\/html><\/code><\/pre>\n\n\n\n<p>This is a little trickier.  When the template is loaded, it is passed a task variable for the task being edited.  The name of the task is set as the initial value in the entry field for name.  There is a checkbox for completed, and this is checked if task.completed is true.<\/p>\n\n\n\n<h2>Finishing the Tasks Controller<\/h2>\n\n\n\n<p>To display these new pages and to perform database operations, you must add code to the controller, controllers\/tasks.js.  Within that file, change the addTask method to read:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const addTask = (req, res) =&gt; {\n    res.render('pages\/addTask')\n}<\/code><\/pre>\n\n\n\n<p>This just renders the addTask.ejs template, with a message if any.  Change the createTask method to read:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const createTask = async (req, res) =&gt; {\n    try {\n        if (req.body.complete) {\n            req.body.completed=true\n        }\n        await Task.create(req.body)\n        req.session.pendingMessage = \"The task was created.\"\n        res.redirect('\/tasks')\n    } catch (err) {\n        if (err.name === 'ValidationError') {\n            res.locals.message = Object.values(err.errors)\n                .map((item) =&gt; item.message)\n                .join(', ')\n        } else {\n            res.locals.message = \"Something went wrong.\"\n        }\n        res.render('pages\/addTask')\n    }\n}<\/code><\/pre>\n\n\n\n<p>Here you are using the values posted in req.body to create a task.  That may succeed or fail, depending on the validation of values.  req.body.complete may have the string value &#8220;true&#8221; for complete, which must be changed to the boolean value of true for completed.  If the create is successful, a pending message (which is displayed after a redirect operation) gives the user feedback, and a redirect is sent back to display the tasks page again.  If the create fails, the user is given a message, which might be a schema validation error, and the add page is rendered again.  Note that the method must be async so that you can await the result of the create operation.<\/p>\n\n\n\n<p>Now change the editTask method to read as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const editTask = async (req, res) =&gt; {\n    try {\n        const task = await Task.findById(req.params.id)\n        res.render('pages\/editTask', { task })\n    } catch (err) {\n        req.session.pendingMessage = 'Something went wrong.'\n        res.redirect('\/tasks')\n    }\n}<\/code><\/pre>\n\n\n\n<p>To edit a task, you have to load it first, hence the findById call.  That may fail in which case the error is reported to the user.  If it succeeds, the task variable is passed to the editTask.ejs on the render.<\/p>\n\n\n\n<p>Now change the updateTask method to read:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const updateTask = async (req, res) => {\n    let task = false\n    try {\n        if (req.body.complete) {\n            req.body.completed=true\n        } else {\n            req.body.completed=false\n        }\n       task = await Task.findById(req.params.id)\n       await Task.findByIdAndUpdate( req.params.id, req.body, {runValidators: true})\n       req.session.pendingMessage = 'The task was updated.'\n       res.redirect('\/tasks')\n    } catch (err) {\n        if (err.name === 'ValidationError') {\n            res.locals.message = Object.values(err.errors)\n                .map((item) => item.message)\n                .join(', ')\n        } else {\n            res.locals.message = \"Something went wrong.\"\n        }\n        if (task) {\n          res.render('pages\/editTask', {task})\n        } else {\n            req.session.pendingMessage = 'Something went wrong.'\n            res.redirect('\/tasks')\n        }\n    }\n}\n<\/code><\/pre>\n\n\n\n<p>FIrst, you find the task being updated.  Then you attempt to update it with the values from the body of the post request.  Then, if that fails, you render the page again, passing the message and the task on the render call.  If it succeeds, you give the user the success message and redirect to the tasks page.<\/p>\n\n\n\n<p>Next, change the getTasks method to read as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const getTasks = async (req, res) =&gt; {\n   try {\n     const tasks = await Task.find()\n     res.render('pages\/tasks',{tasks})\n   } catch (err) {\n       res.locals.message = 'Something went wrong.'\n       res.render('pages\/tasks', {tasks: &#91;]})\n   }\n}<\/code><\/pre>\n\n\n\n<p>This method retrieves the list of tasks.  It may be an empty array, or a list of tasks, which is passed on the render call to the tasks.ejs template on the render call.<\/p>\n\n\n\n<p>Finally, make this small change to views\/partials\/header.ejs:  Add these lines to the navbar between the nav-items for home and about:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>      &lt;li class=\"nav-item\"&gt;\n        &lt;a class=\"nav-link\" href=\"\/tasks\"&gt;Tasks&lt;\/a&gt;\n      &lt;\/li&gt;<\/code><\/pre>\n\n\n\n<p>At this point, try the application out.  You should be able to view, add, and edit tasks.  Delete still does not work.  That is left for you to complete.  You need to change the deleteTask method in the controller to issue a findByIdAndDelete.  Then it should should display a message on the success or failure of the operation and then redirect to the tasks page.<\/p>\n\n\n\n<p><strong>Mindset Assignment<\/strong><\/p>\n\n\n\n<p>Your mindset assignment for this week can be found here: <strong><a href=\"https:\/\/learn.codethedream.org\/mindset-curriculum-accessibility-a11y\/\" target=\"_blank\" rel=\"noreferrer noopener\">Accessibility<\/a><\/strong><\/p>\n\n\n\n<h2><strong>Submitting Your Work<\/strong><\/h2>\n\n\n\n<p>When you are done, do the following, use the same procedure as for previous lessons. You do a git add, git commit, and git push for the week13 branch, create your pull request on github, and put a link to your pull request in your assignment submission form below.<\/p>\n\n\n\n<p><strong>When you\u2019ve completed your Coding Assignment and Mindset Assignment submit ALL of your work using the&nbsp;<a href=\"http:\/\/tiny.cc\/squibby2\">Squibby 2.0 Assignment Submission Form<\/a><\/strong><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Lesson Materials In this lesson, you learn EJS, a templating language for Express. The templates contain embedded JavaScript, which is executed on the server side. This constructs an ordinary HTML page, but with dynamic content. Because the embedded JavaScript runs on the server, before the page is sent to the client, dynamic content can be<\/p>\n","protected":false},"author":5,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":"","_vp_format_video_url":"","_vp_image_focal_point":[]},"featured_image_src":null,"featured_image_src_square":null,"_links":{"self":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1590"}],"collection":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/users\/5"}],"replies":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/comments?post=1590"}],"version-history":[{"count":0,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1590\/revisions"}],"wp:attachment":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/media?parent=1590"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}