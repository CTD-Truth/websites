{"id":1272,"date":"2021-08-21T11:23:21","date_gmt":"2021-08-21T15:23:21","guid":{"rendered":"https:\/\/learn.codethedream.org\/?page_id=1272"},"modified":"2022-02-21T18:05:58","modified_gmt":"2022-02-21T23:05:58","slug":"documenting-rest-apis-with-swagger","status":"publish","type":"page","link":"https:\/\/learn.codethedream.org\/documenting-rest-apis-with-swagger\/","title":{"rendered":"Documenting REST APIs with Swagger"},"content":{"rendered":"\n<p>When you create a REST API, you also need (a) an automated way to test the API, something easier than curl, and (b) a way to document the API, so that implementers of front end applications that call the API can know how to call it.  RSpec may be used to test APIs as well as to test Rails UI applications.  The standard and best way to document the API is to create a special user interface for it called Swagger. <\/p>\n\n\n\n<p>We will create a partial set of RSpec tests.  These tests will be of a particular format, so that they can be used to generate the Swagger UI.<\/p>\n\n\n\n<h2 id=\"setting-up-for-rspec-and-swagger\">Setting Up for Rspec and Swagger<\/h2>\n\n\n\n<p>Add the following lines to your Gemfile:<\/p>\n\n\n\n<p>First, in the section before the group :development, :test line, add these lines to get the swagger gem:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>gem 'rspec-rails'\ngem 'rexml'\ngem 'rswag'<\/code><\/pre>\n\n\n\n<p>The rswag line is to add the swagger gem.   Then, add a group :test section to your Gemfile, near the bottom, which should look like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>group :test do\n  gem 'factory_bot_rails'\n  gem 'faker'\n  gem 'rails-controller-testing'\nend<\/code><\/pre>\n\n\n\n<p>When all of these changes have been made, do a bundle install to load the new gems.  Then, complete the installation of the rswag and rspec-rails gems with these commands:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails generate rspec:install\nbin\/rails generate rswag:install<\/code><\/pre>\n\n\n\n<h2 id=\"factories-and-rspec-tests\">Factories and RSpec Tests<\/h2>\n\n\n\n<p>You will need FactoryBot factories for test user, member, and fact entries.  Create spec\/factories\/users.rb as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'faker'\n\nFactoryBot.define do\n  factory :user do |f|\n    f.email { Faker::Internet.email }\n    f.password { Faker::Internet.password }\n  end\nend<\/code><\/pre>\n\n\n\n<p>Create also spec\/factories\/members.rb as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'faker'\n\nFactoryBot.define do\n  factory :member do |f|\n    f.first_name { Faker::Name.name }\n    f.last_name { Faker::Lorem.word }\n  end\nend<\/code><\/pre>\n\n\n\n<p>Create also spec\/factories\/facts.rb as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>FactoryBot.define do\n  factory :fact do\n    fact_text { Faker::ChuckNorris.fact }\n    likes { Faker::Number.number(digits: 3).to_i }\n    association :member\n  end\nend<\/code><\/pre>\n\n\n\n<h2 id=\"creating-the-rspec-tests\">Creating the Rspec Tests<\/h2>\n\n\n\n<p>We need to create tests for each of the controllers.  First, create spec\/requests\/registrations_spec.rb, as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'swagger_helper'\n\nRSpec.describe 'user\/registrations', type: :request do\n  path '\/users' do\n    post 'create user' do\n      tags 'Registrations'\n      consumes 'application\/json'\n      produces 'application\/json'\n      parameter name: :user, in: :body, required: true, schema: {\n        type: :object,\n        required: %i&#91;email password],\n        properties: { user: { properties: {\n          email: { type: :string },\n          password: { type: :string }\n        }}}\n      }\n      response(201, 'successful') do\n        let(:user1) { FactoryBot.attributes_for(:user) }\n        let(:user) do\n          { user: {\n              email: user1&#91;:email],\n              password: user1&#91;:password]\n          }}\n        end\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n  end\nend<\/code><\/pre>\n\n\n\n<p>The swagger gem is here introducing some domain specific language into rspec.  This is done so that the Swagger UI can be generated from the rspec tests.  You have a series of path statements corresponding to your rails routes,  and get\/post\/put\/patch\/delete statements also corresponding to the routes.  We also specify the parameters and their types.  We are just testing that a valid return code and json body comes back.  Good rspec testing would add a number of expect statements to make sure the body is valid, and additional test cases would be provided for invalid data.  So what we have is too limited to be a comprehensive test, but it suffices to generate swagger code.  (By the way, the swagger gem has the capability to generate an outline for these test files &#8212; unfortunately there is a bug in that function so we avoid it for now.)<\/p>\n\n\n\n<p>We also need tests for the sessions controller. We will need to enable authentication for some of these tests.  There are helper routines in Devise JWT to facilitate this.  To have access to these helper routines, add the following line to the top of spec\/spec_helper.rb:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'devise\/jwt\/test_helpers'<\/code><\/pre>\n\n\n\n<p>Create spec\/requests\/sessions_spec.rb as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'swagger_helper'\n\ndescribe 'sessions API' do\n  #Creates swagger for documentaion for login\n  path '\/users\/sign_in' do\n\n    post 'Creates a session' do\n      let(:user1) { FactoryBot.create(:user) }\n      tags 'sessions'\n      consumes 'application\/json'\n      produces 'application\/json'\n      parameter name: :user, in: :body, required: true, schema: {\n        type: :object,\n        properties: { user: { properties: {\n          email: { type: :string },\n          password: { type: :string}\n        }}},\n        required: &#91; 'email', 'password' ]\n      }\n\n      response '201', 'session jwt token created' do\n        let(:user) do\n          { user: {\n              email: user1.email,\n              password: user1.password\n          }}\n        end\n        run_test!\n      end\n\n      response '401', 'Unauthorized' do\n        let(:user) do\n          { user: {\n              email: user1.email,\n              password: \"\"\n          } }\n        end\n        run_test!\n      end\n    end\n  end\n\n#Swagger documentation for logout.\n  path '\/users\/sign_out' do\n\n    delete 'Destroy JWT token' do\n      let(:user) { FactoryBot.create(:user) }\n      let (:auth_header) {\"Bearer \"+Warden::JWTAuth::UserEncoder.new.call(user, :user,nil)&#91;0]}\n      tags 'sessions'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      #This includes a valid auth token header\n        response '200', 'blacklist token' do\n          let(:\"Authorization\") {auth_header}\n          run_test!\n        end\n        #This does not include anything in the header so it fails\n      response '401', 'no token to blacklist' do\n        let(:\"Authorization\") {}\n        run_test!\n      end\n    end\n  end\nend<\/code><\/pre>\n\n\n\n<p>By creating the test for the sessions controller, we provide a means for the user to log on using the Swagger interface.  We also document logout.  For logout it is necessary that the user be authenticated.  So we have to create a user, and then a token associated with that user.  That is done with the lines<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>   let(:user) { FactoryBot.create(:user) }\n      let (:auth_header) {\"Bearer \"+Warden::JWTAuth::UserEncoder.new.call(user, :user,nil)&#91;0]}<\/code><\/pre>\n\n\n\n<p>To have access to the JWTAuth helper that creates the token, we have to require the jwt test helpers,  as per the second line in this file.  We also have to tell swagger that authentication is needed for this API.  That is done with the line:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>      security &#91;Bearer: {}]<\/code><\/pre>\n\n\n\n<p>Next we create a test for the members controller, and for each of the methods within that controller.  Every method within the members controller requires authentication.  Create spec\/requests\/api\/v1\/members_spec.rb as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'swagger_helper'\n\nRSpec.describe 'api\/v1\/members', type: :request do\n  let(:user1) { FactoryBot.create(:user) }\n  let (:token){Warden::JWTAuth::UserEncoder.new.call(user1,:user,nil)}\n  let(:Authorization){ \"Bearer \"+ token&#91;0]}\n  let!(:members) { FactoryBot.create_list(:member, 10) }\n  let(:member_id) { members.first.id }\n\n  path '\/api\/v1\/members' do\n\n    get('list members') do\n      tags 'Members'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      response(200, 'successful') do\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    post('create member') do\n      tags 'Members'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      parameter name: :member, in: :body, required: true, schema: {\n        type: :object,\n        required: %i&#91;first_name last_name],\n        properties: {\n          first_name: { type: :string },\n          last_name: { type: :string }\n        }\n      }\n\n      response(201, 'successful') do\n        let(:member) { { first_name: \"jqpublic23\", last_name: \"mypasswd\"}}\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n  end\n\n  path '\/api\/v1\/members\/{id}' do\n    parameter name: 'id', in: :path, type: :string, description: 'id'\n\n    get('show member') do\n      tags 'Members'\n      security &#91;Bearer: {}]\n      response(200, 'successful') do\n        let(:id) { member_id }\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    patch('update member') do\n      tags 'Members'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      parameter name: :member, in: :body, schema: {\n        type: :object,\n        properties: {\n          first_name: { type: :string },\n          last_name: { type: :string }\n        }\n      }\n      response(200, 'successful') do\n        let(:id) { member_id }\n        let(:member) {{first_name: 'fred'}}\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    put('update member') do\n      tags 'Members'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      parameter name: :member, in: :body, schema: {\n        type: :object,\n        properties: {\n          first_name: { type: :string },\n          last_name: { type: :string }\n        }\n      }\n      response(200, 'successful') do\n        let(:id) { member_id }\n        let(:member) {{first_name: 'fred'}}\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    delete('delete member') do\n      tags 'Members'\n      security &#91;Bearer: {}]\n      response(200, 'successful') do\n        let(:id) { member_id }\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n  end\nend<\/code><\/pre>\n\n\n\n<p>Finally, we create the test file for facts, as spec\/requests\/api\/v1\/facts_spec.rb;<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'swagger_helper'\n\nRSpec.describe 'api\/v1\/facts', type: :request do\n  # Initialize the test data\n  let(:user1) { FactoryBot.create(:user) }\n  let (:token){Warden::JWTAuth::UserEncoder.new.call(user1,:user,nil)}\n  let(:Authorization){ \"Bearer \"+ token&#91;0]}\n\n  let!(:member) { FactoryBot.create(:member) }\n  let!(:facts) { FactoryBot.create_list(:fact, 20, member_id: member.id) }\n  let(:member_id) { member.id }\n  let(:fact_id) { facts.first.id }\n\n  path '\/api\/v1\/members\/{member_id}\/facts' do\n    parameter name: 'member_id', in: :path, type: :string, description: 'member_id'\n\n    get('list facts') do\n      tags 'Facts'\n      security &#91;Bearer: {}]\n      response(200, 'successful') do\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    post('create fact') do\n      tags 'Facts'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      parameter name: :fact, in: :body, required: true, schema: {\n        type: :object,\n        required: %i&#91;fact_text likes],\n        properties: {\n          fact_text: {type: :string},\n          likes: {type: :integer}\n        }\n      }\n      response(201, 'successful') do\n        let(:fact) { { fact_text: \"This is a fact.\", likes: 15} }\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n  end\n\n  path '\/api\/v1\/members\/{member_id}\/facts\/{fact_id}' do\n    parameter name: 'member_id', in: :path, type: :string, description: 'member_id'\n    parameter name: 'fact_id', in: :path, type: :string, description: 'id'\n\n    get('show fact') do\n      tags 'Facts'\n      security &#91;Bearer: {}]\n      response(200, 'successful') do\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    patch('update fact') do\n      tags 'Facts'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n      parameter name: :fact, in: :body, required: true, schema: {\n        type: :object,\n        properties: {\n          fact_text: {type: :string},\n          likes: {type: :integer}\n        }\n      }\n      response(200, 'successful') do\n        let(:fact) { {fact_text: \"This is another fact.\"}}\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    put('update fact') do\n      tags 'Facts'\n      consumes 'application\/json'\n      produces 'application\/json'\n      security &#91;Bearer: {}]\n          parameter name: :fact, in: :body, required: true, schema: {\n        type: :object,\n        properties: {\n          fact_text: {type: :string},\n          likes: {type: :integer}\n        }\n      }\n      response(200, 'successful') do\n        let(:fact) {{ fact_text: \"This is another fact.\" }}\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n\n    delete('delete fact') do\n      tags 'Facts'\n      security &#91;Bearer: {}]\n      response(200, 'successful') do\n\n        after do |example|\n          example.metadata&#91;:response]&#91;:examples] = { 'application\/json' =&gt; JSON.parse(response.body, symbolize_names: true) }\n        end\n        run_test!\n      end\n    end\n  end\nend<\/code><\/pre>\n\n\n\n<p>Edit spec\/swagger_helper.rb to read as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code># frozen_string_literal: true\n\nrequire 'rails_helper'\n\nRSpec.configure do |config|\n  # Specify a root folder where Swagger JSON files are generated\n  # NOTE: If you're using the rswag-api to serve API descriptions, you'll need\n  # to ensure that it's configured to serve Swagger from the same folder\n  config.swagger_root = Rails.root.join('swagger').to_s\n\n  # Define one or more Swagger documents and provide global metadata for each one\n  # When you run the 'rswag:specs:swaggerize' rake task, the complete Swagger will\n  # be generated at the provided relative path under swagger_root\n  # By default, the operations defined in spec files are added to the first\n  # document below. You can override this behavior by adding a swagger_doc tag to the\n  # the root example_group in your specs, e.g. describe '...', swagger_doc: 'v2\/swagger.json'\n  config.swagger_docs = {\n    'v1\/swagger.yaml' =&gt; {\n      openapi: '3.0.1',\n      info: {\n        title: 'API V1',\n        version: 'v1'\n      },\n      paths: {},\n      components: {\n        securitySchemes: {\n          Bearer: {\n            description: \"Bearer token\",\n            type: :apiKey,\n            name: 'Authorization',\n            in: :header\n          }\n        }\n      },\n      servers: &#91;\n        {\n          url: \"#{ENV&#91;'APPLICATION_URL']}\"\n        }\n      ]\n    }\n  }\n\n  # Specify the format of the output Swagger file when running 'rswag:specs:swaggerize'.\n  # The swagger_docs configuration option has the filename including format in\n  # the key, this may want to be changed to avoid putting yaml in json files.\n  # Defaults to json. Accepts ':json' and ':yaml'.\n  config.swagger_format = :yaml\nend<\/code><\/pre>\n\n\n\n<p>You are really only changing two sections.  You are changing the server section so that the swagger UI has the right URL, and you are also specifying what kind of authentication is to be used in the securitySchemes section.<\/p>\n\n\n\n<p>Now run rspec.  It should complete without errors.  If not, you may have problems in your controller logic.<\/p>\n\n\n\n<h2 id=\"creating-the-swagger-ui\">Creating the Swagger UI<\/h2>\n\n\n\n<p>Type:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bundle exec rake rswag:specs:swaggerize<\/code><\/pre>\n\n\n\n<p>Then start your server as usual.  You will find that you have a new route, so that you can, from your browser, access http:\/\/localhost:3000\/api-docs . Experiment with this page, using the registrations section to create users and using the sessions section to log on.  <\/p>\n\n\n\n<p>You will find that  the logoff as well as all of the sections for members and facts don&#8217;t appear to work.  They always return a 401 for unauthorized.  You can set up authentication for these operations as follows.  First, do a logon for a user you have created.  You will see it returns a response with an Authorization header.  Copy the contents of the Authorization header, which starts with Bearer and continues with a log string of characters, that being the JWT token, something like:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>Bearer eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiI1Iiwic2NwIjoidXNlciIsImF1ZCI6bnVsbCwiaWF0IjoxNjI5NDc0NzM1LCJleHAiOjE2Mjk0NzgzMzUsImp0aSI6IjA2MWZmNDQxLTA2NmQtNDAwZS1hZDk4LWM4MWEyYThiMzgzMSJ9.HP3bz_xDEd8_00MfG2ZNR61afUXf-YujinwSdExmkig<\/code><\/pre>\n\n\n\n<p>You won&#8217;t be able to use the token above, because it wasn&#8217;t generated by your server, but you can use the token returned by the logon operation.  Now scroll to the top of the swagger page.  You will see a button with Authorize and a lock icon.  Click on it.  It will open a little dialog box prompting you for the value.  Paste in the Authorization header you copied, and then click on authorize and then on close.  Verify that you can now do the member and facts operations on the swagger page.<\/p>\n\n\n\n<p>When you have verified that each of the operations on the swagger page works, you have completed the lesson.  Use git to add, commit, and push your changes to the swagger branch, and then create a pull request as usual.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>When you create a REST API, you also need (a) an automated way to test the API, something easier than curl, and (b) a way to document the API, so that implementers of front end applications that call the API can know how to call it. RSpec may be used to test APIs as well<\/p>\n","protected":false},"author":5,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":"","_vp_format_video_url":"","_vp_image_focal_point":[]},"featured_image_src":null,"featured_image_src_square":null,"_links":{"self":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1272"}],"collection":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/users\/5"}],"replies":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/comments?post=1272"}],"version-history":[{"count":0,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1272\/revisions"}],"wp:attachment":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/media?parent=1272"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}