{"id":1599,"date":"2022-04-12T13:03:25","date_gmt":"2022-04-12T17:03:25","guid":{"rendered":"https:\/\/learn.codethedream.org\/?page_id=1599"},"modified":"2022-07-26T17:49:48","modified_gmt":"2022-07-26T21:49:48","slug":"ctd-node-express-class-lesson-b-authentication-for-pages","status":"publish","type":"page","link":"https:\/\/learn.codethedream.org\/ctd-node-express-class-lesson-b-authentication-for-pages\/","title":{"rendered":"CTD Node\/Express Class Lesson 13: Authentication with Passport"},"content":{"rendered":"\n<h2><strong>Lesson Materials<\/strong><\/h2>\n\n\n\n<p>When you are creating APIs, you can perform authentication using JavaScript Web Tokens (JWTs).  The front end makes an API call passing credentials to the back end, and the back end returns a token.  The front end then passes this token in the authorization header on all subsequent requests.  When the application does not have a separate front end to invoke the APIs, this can&#8217;t work.  The browser is making the requests, and browsers can&#8217;t call APIs or send authorization headers.  But there has to be some way to save state, such as the state of being logged on.  For applications that are not based on APIs, such as server side rendered applications, this is done using sessions, and sessions are established and maintained using cookies.<\/p>\n\n\n\n<p>This is the flow:  The browser requests a page from the server.  The server includes middleware that includes a set-cookie header in the response to the browser.  The cookie is a cryptographically signed string, signed with a secret key so that it can&#8217;t be counterfeited by a malicious user.  The browser automatically includes the cookie in the header of all subsequent requests to the same URL, until the cookie expires.  Different browser sessions from different users have different cookie values.  On the server side, the cookie is used as a key to access session state data, which is kept on the server.  This state data is the user&#8217;s session.<\/p>\n\n\n\n<p>The user session keeps information on whether the user is logged on, and if so, which user it is.  A logon sends user credentials from an HTML form, and if that succeeds, the session is updated.  A logoff deletes the user session information.<\/p>\n\n\n\n<h2><strong>Assignments<\/strong><\/h2>\n\n\n\n<p><strong>Coding Assignment<\/strong><\/p>\n\n\n\n<p>In this lesson, you use the express-session, passport, and passport-local packages to handle user authentication, from within a server-side rendered application.<\/p>\n\n\n\n<h2>First Steps<\/h2>\n\n\n\n<p>The lesson begins at this link: <a href=\"https:\/\/www.theodinproject.com\/lessons\/nodejs-authentication-basics\">Authentication Basics | The Odin Project<\/a> .   You should do your work in a passport-demo directory, which would be in the same directory as the node-express-course folder, but it should not be inside the node-express-course tree.  There are some additional steps you need to take, and explanations on unclear points, and these are below.  The information at the link recommends that you put the Mongo URL, including a password, into the code.  This is a very bad practice, so <strong>don&#8217;t do it<\/strong>.  The lesson at the link also has you put the session secret in the code, using the value &#8220;cats&#8221;.  This is also a very bad practice.  Instead, use dotenv and an .env file to store these values. The lesson simplifies some things, which makes it a little crude: all the code is in a single app.js file, so there aren&#8217;t separate model, view, routes, and controllers directories.<\/p>\n\n\n\n<p> For the npm install, you will need to do also:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>npm install dotenv\nnpm install nodemon --save-dev<\/code><\/pre>\n\n\n\n<p>Create a .env file in the passport-demo.  This must have a line for the MONGO_URI.  You use the same MONGO_URI as for the previous lesson, except you use a new database name, PASSPORT-DEMO.  The .env file must also have a line for SESSION_SECRET, and the value should be a long, difficult to guess string.  Create also a .gitignore file, also in the passport-demo directory.  You will submit this work to github, so you need to make sure that the .env file is not stored on github.  The .gitignore should read:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>.env\n\/node_modules<\/code><\/pre>\n\n\n\n<p>Edit the package.json file to add these lines to the scripts section.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    \"start\": \"node app\",\n    \"dev\": \"nodemon app\"<\/code><\/pre>\n\n\n\n<p>This way, you can test your application using &#8220;npm run dev&#8221;.  <\/p>\n\n\n\n<p>When you create the app.js,  add this line to the top of the file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require('dotenv').config<\/code><\/pre>\n\n\n\n<p>Also, the line that reads<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const mongoDb = \"YOUR MONGO URL HERE\";<\/code><\/pre>\n\n\n\n<p>should be changed to read<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const mongoDb = process.env.MONGO_URI<\/code><\/pre>\n\n\n\n<p>And, the line that reads<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.use(session({ secret: \"cats\", resave: false, saveUninitialized: true }));<\/code><\/pre>\n\n\n\n<p>should be changed to read<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.use(session({ secret: process.env.SESSION_SECRET, resave: false, saveUninitialized: true }));<\/code><\/pre>\n\n\n\n<p>Continue with the lesson, until you come to the part about &#8220;A Quick Tip&#8221;.  That&#8217;s not clear.  Add the recommended middleware above your routes.  You can then change<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  res.render(\"index\", { user: req.user });<\/code><\/pre>\n\n\n\n<p>to read just<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  res.render(\"index\");<\/code><\/pre>\n\n\n\n<p>and you also change index.ejs so that instead of user.username, it has currentUser.username.  The point is that the variables in res.locals are always available inside of the templates.<\/p>\n\n\n\n<p>The section on bcrypt.hash and bcrypt.compare is also a little unclear.  Once you have installed bcryptjs and added the require statement for it, you change the app.post for &#8220;\/sign-up&#8221; to read<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.post(\"\/sign-up\", async (req, res, next) => {\n  try {\n    const hashedPassword = await bcrypt.hash(req.body.password, 10)\n    await User.create({ username: req.body.username, password: hashedPassword })\n    res.redirect(\"\/\");\n  } catch (err) {\n    return next(err)\n  }\n});<\/code><\/pre>\n\n\n\n<p>and you change the passport.use section to read<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>passport.use(\n  new LocalStrategy((username, password, done) =&gt; {\n    User.findOne({ username: username }, (err, user) =&gt; {\n      if (err) {\n        return done(err);\n      }\n      if (!user) {\n        return done(null, false, { message: \"Incorrect username\" });\n      }\n      bcrypt.compare(password, user.password, (err, result) =&gt; {\n        if (result) {\n          return done(null, user)\n        } else {\n          return done(null, false, { message: \"Incorrect password\" })\n        }\n      })\n\n    });\n  })\n);<\/code><\/pre>\n\n\n\n<p>This is kind of a crude approach for simplicity.  It would be better to extend the schema for User as was done in earlier lessons on JWT authentication, but this is one way to do it.<\/p>\n\n\n\n<p>Test the application to make sure it works.  You now add some things.<\/p>\n\n\n\n<h2>Additions to the Lesson<\/h2>\n\n\n\n<p>Within the browser window that is running the application, bring up developer tools.  In the Chrome developer tools you click on application.  Then on the left side of the screen you see a section for cookies.  Click on the cookie for http:\/\/localhost:3000.  You see a cookie with the name of connect.sid.  This is the cookie stored by express.session.  It does not actually contain the session data.  Instead it contains a cryptographically signed key into the session data stored on the server.<\/p>\n\n\n\n<p>The code now does a req.logout() when the user logs off.  It is better to delete all the session information at logoff time.  So change that code as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.get(\"\/log-out\", (req, res) =&gt; {\n  req.session.destroy(function (err) {\n    res.redirect(\"\/\")\n  })\n});<\/code><\/pre>\n\n\n\n<p>Notice that if you attempt to logon with an incorrect password, it just redisplays the logon form.  The message is not returned to the user.  Let&#8217;s fix that.  First, change the passport.authenticate part to read:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  passport.authenticate(\"local\", {\n    successRedirect: \"\/\",\n    failureRedirect: \"\/\",\n    failureMessage: true\n  })<\/code><\/pre>\n\n\n\n<p>Passport documentation is clumsy, but this is the way Passport error messages into the session, so that they can be displayed on subsequent screens.  The messages are put in an array, req.session.messages.  This can then be displayed in the index.ejs.  First, change the route that displays index.ejs so that it reads:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.get(\"\/\", (req, res) =&gt; {\n  let messages = &#91;]\n  if (req.session.messages) {\n    messages = req.session.messages\n    req.session.messages = &#91;]\n  }\n  res.render(\"index\", { messages });\n});<\/code><\/pre>\n\n\n\n<p>Then, change index.ejs to add these lines, right under the &lt;h1&gt; for Please Log In:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>    &lt;% messages.forEach((msg) =&gt;{ %&gt;\n       &lt;p&gt;&lt;%= msg %&gt;&lt;\/p&gt;\n    &lt;% }) %&gt;<\/code><\/pre>\n\n\n\n<p>Then, try logging on with an incorrect password.  You should see an error message.<\/p>\n\n\n\n<p>Once authentication is enabled, you need to perform access control, so that certain pages are restricted only to those users that log in.  This is done with middleware.  Add the following code above your routes:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const authMiddleware = (req, res, next) =&gt; {\n  if (!req.user) {\n    if (!req.session.messages) {\n      req.session.messages = &#91;]\n    }\n    req.session.messages.push(\"You can't access that page before logon.\")\n    res.redirect('\/')\n  } else {\n    next()\n  }\n}<\/code><\/pre>\n\n\n\n<p>This code redirects the user to the logon page with a message if the user attempts to access a restricted page without being logged in.  To test this, first create a page that will be restricted, restricted.ejs:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt;\n    &lt;title&gt;Restricted&lt;\/title&gt;\n&lt;\/head&gt;\n&lt;body&gt;\n   &lt;p&gt;This page is restricted.  You can't see it unless you are logged on.&lt;\/p&gt;\n   &lt;p&gt;You have visited this page &lt;%= pageCount %&gt; times since logon.&lt;\/p&gt; \n&lt;\/body&gt;\n&lt;\/html&gt;<\/code><\/pre>\n\n\n\n<p>Then, create the route statement that loads the page, as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.get('\/restricted', authMiddleware, (req, res) =&gt; {\n  if (!req.session.pageCount) {\n    req.session.pageCount = 1\n  } else {\n    req.session.pageCount++\n  }\n  res.render('restricted', { pageCount: req.session.pageCount })\n})<\/code><\/pre>\n\n\n\n<p>Here the code shows also how the session can be used to store state, in this case the number of page visits.<\/p>\n\n\n\n<h2>A Production Grade Session Store<\/h2>\n\n\n\n<p>The code, as written, stores session data in memory.  That is the default for express-session.  However, this approach should never be used in production, because (a) if the application is restarted, all session data is lost, and (b) session data could fill up memory.  A production application stores session data another way, and there are a variety of choices.  Here we use MongoDB.<\/p>\n\n\n\n<p>First, do an npm install of connect-mongodb-session.  Then add the following lines to app.js underneath your existing require statements:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>const MongoDBStore = require('connect-mongodb-session')(session)\n\nvar store = new MongoDBStore({\n  uri: process.env.MONGO_URI,\n  collection: 'sessions'\n});\n\n\/\/ Catch errors\nstore.on('error', function (error) {\n  console.log(error);\n});<\/code><\/pre>\n\n\n\n<p>Then change the app.use for session to read:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>app.use(session({\n  secret: process.env.SESSION_SECRET, resave: false, saveUninitialized: true,\n  store: store\n}))<\/code><\/pre>\n\n\n\n<p>Retest the application.  It should work as before.  Logon to your mongodb.com account and check out the PASSPORT-DEMO database.  You see two collections, one for users and one for sessions, and you can check to see what information is stored in the session record.<\/p>\n\n\n\n<p><strong>Mindset Assignment<\/strong><\/p>\n\n\n\n<p>Your mindset assignment for this week can be found here: <strong><a href=\"https:\/\/learn.codethedream.org\/mindset-curriculum-debugging-part-2\/\" target=\"_blank\" rel=\"noreferrer noopener\">Debugging &#8211; part 2<\/a><\/strong><\/p>\n\n\n\n<h2><strong>Submitting Your Work<\/strong><\/h2>\n\n\n\n<p>You submit your work via github, as you did for the ejs-demo application.  <strong>Be careful that you have a .gitignore file that lists .env, so that you do not disclose your MongoDB password on github.  The steps are<\/strong><\/p>\n\n\n\n<ol><li>Create a passport-demo repository on github.<\/li><li>Within the passport-demo directory on your machine, do a git init.<\/li><li>git add -A <\/li><li>git commit -m &#8220;first commit&#8221;<\/li><li>git remote add origin &lt; the github repository URL for passport-demo &gt;<\/li><li>git push -u origin main<\/li><\/ol>\n\n\n\n<p>When you are done, use the same procedure as for previous lessons. You do a git add, git commit, and git push for the week14 branch, create your pull request on github, and put a link to your pull request in your assignment submission form below.<\/p>\n\n\n\n<p><strong>When you\u2019ve completed your Coding Assignment and Mindset Assignment submit ALL of your work using the&nbsp;<a href=\"http:\/\/tiny.cc\/squibby2\">Squibby 2.0 Assignment Submission Form<\/a><\/strong><\/p>\n","protected":false},"excerpt":{"rendered":"<p>Lesson Materials When you are creating APIs, you can perform authentication using JavaScript Web Tokens (JWTs). The front end makes an API call passing credentials to the back end, and the back end returns a token. The front end then passes this token in the authorization header on all subsequent requests. When the application does<\/p>\n","protected":false},"author":5,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":"","_vp_format_video_url":"","_vp_image_focal_point":[]},"featured_image_src":null,"featured_image_src_square":null,"_links":{"self":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1599"}],"collection":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/users\/5"}],"replies":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/comments?post=1599"}],"version-history":[{"count":0,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/1599\/revisions"}],"wp:attachment":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/media?parent=1599"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}