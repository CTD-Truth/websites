{"id":801,"date":"2020-12-30T12:30:52","date_gmt":"2020-12-30T17:30:52","guid":{"rendered":"https:\/\/learnctd.wpengine.com\/?page_id=801"},"modified":"2021-12-17T21:54:36","modified_gmt":"2021-12-18T02:54:36","slug":"rails-basic-skills-rspec","status":"publish","type":"page","link":"https:\/\/learn.codethedream.org\/rails-basic-skills-rspec\/","title":{"rendered":"Rails Basic Skills: RSpec"},"content":{"rendered":"\n<p>Testing validates that the application does what it is supposed to do.&nbsp; Also, applications change over time as new features are added.&nbsp; It is very easy to break an application by making changes.&nbsp; Automated testing can ensure that such breaks are rare.<\/p>\n\n\n\n<p>Often, the tests are written before the application code.&nbsp; This is called test driven development.&nbsp; The code can then be tested as it is being written.<\/p>\n\n\n\n<p>The ability to do automated testing is a valuable skill with potential employers.  Sometimes you can get hired to create automated tests before moving up to development.<\/p>\n\n\n\n<p>RSpec is the most common tool for testing Rails applications.<\/p>\n\n\n\n<h2>Some Test Types<\/h2>\n\n\n\n<p>Model testing: Tests that models validate as they should, and that all methods work.<\/p>\n\n\n\n<p>Request testing: Tests that the controller does what it should, either for processing HTTP requests or for API endpoints<\/p>\n\n\n\n<p>Feature testing: Feature testing for a web application actually executes browser operations, entering data in fields, clicking on buttons, and checking the screens that come back.&nbsp; This is complicated to set up, so we won\u2019t work on it in this lesson.&nbsp; However, feature testing is very important for the end product.<\/p>\n\n\n\n<p>System testing: End-to-end testing of the application<\/p>\n\n\n\n<h2>Some References on RSpec Testing: Recommended Reading<\/h2>\n\n\n\n<p><a href=\"https:\/\/semaphoreci.com\/community\/tutorials\/how-to-test-rails-models-with-rspec\">How to Test Rails Models with RSpec &#8211; Semaphore<\/a> (very basic and easy to follow)<\/p>\n\n\n\n<p><a href=\"https:\/\/www.rubyguides.com\/2018\/07\/rspec-tutorial\/\">https:\/\/www.rubyguides.com\/2018\/07\/rspec-tutorial\/<\/a> (This one\u2019s about testing in ruby, not so much about rails)<\/p>\n\n\n\n<p><a href=\"https:\/\/www.sitepoint.com\/learn-the-first-best-practices-for-rails-and-rspec\/\">https:\/\/www.sitepoint.com\/learn-the-first-best-practices-for-rails-and-rspec\/<\/a> (A comprehensive tutorial.&nbsp; There are references to FactoryGirl, which has now been replaced by FactoryBot.)<\/p>\n\n\n\n<h2>Git Setup for the RSpec Assignment<\/h2>\n\n\n\n<p>We are going to use a new git branch of your existing customer application for this.&nbsp; For your validations branch, make sure you have committed all your changes and pushed them to github.&nbsp; Then do the following commands.&nbsp; The validations branch should be active when you create the rspec branch, so that it includes the changes in the validations branch.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>git checkout -b rspec<\/code><\/pre>\n\n\n\n<h2>Additional Gem Files for RSpec Testing<\/h2>\n\n\n\n<p>We will do automated testing for the customer-order application.&nbsp; Edit the Gemfile.&nbsp; Add the following lines to the :development, :test section of the Gemfile:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>gem 'rspec-rails'\ngem 'factory_bot_rails'\ngem 'faker'\ngem 'rails-controller-testing'\ngem 'rexml'<\/code><\/pre>\n\n\n\n<p>These gems will be used to enable testing.&nbsp; After saving your Gemfile, run:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bundle install<\/code><\/pre>\n\n\n\n<h2>More Setup<\/h2>\n\n\n\n<p>Enter the following command to complete the setup of rspec:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails generate rspec:install<\/code><\/pre>\n\n\n\n<p>Then enter this command to set up the test database:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails db:migrate db:test:prepare<\/code><\/pre>\n\n\n\n<p>Then, enter these commands to set up the shells of test classes for the customer model and customers controller:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails generate rspec:model Customer\nbin\/rails generate rspec:request Customers\n<\/code><\/pre>\n\n\n\n<h2>Generated Files<\/h2>\n\n\n\n<p>The shells of two test case files have been generated.&nbsp; These are:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>.\/spec\/models\/customer_spec.rb\n.\/spec\/requests\/customers_spec.rb\n<\/code><\/pre>\n\n\n\n<p>You can now run rspec, using the command:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bundle exec rspec<\/code><\/pre>\n\n\n\n<p>But as the test cases have not been written, it won\u2019t test anything.&nbsp; Edit spec\/models\/customer_spec.rb, copying the following code.<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'rails_helper'\nRSpec.describe Customer, type: :model do\n  subject { Customer.new(first_name: \"Jack\", last_name: \"Smith\", phone: \"8889995678\", email: \"jsmith@sample.com\" )}\n  it \"is valid with valid attributes\" do\n    expect(subject).to be_valid\n  end\n  it \"is not valid without a first_name\" do\n    subject.first_name=nil\n    expect(subject).to_not be_valid\n  end\n  it \"is not valid without a last_name\" do\n    subject.last_name=nil\n    expect(subject).to_not be_valid\n  end\n  it \"is not valid without a phone number\"\n  it \"is not valid without an email\"\n  it \"is not valid if the phone number is not 10 chars\"\n  it \"is not valid if the phone number is not all digits\"\n  it \"is not valid if the email address doesn't have a @\"\n  it \"returns the correct full_name\" do\n    expect(subject.full_name).to eq(\"Jack Smith\")\n  end\nend\n<\/code><\/pre>\n\n\n\n<h2>RSpec Model Test Code Explained<\/h2>\n\n\n\n<p>Rspec introduces some domain specific language.&nbsp; The Rspec.describe do\/end block describes what the type of object, in this case a model class, should do.&nbsp; We start out with a subject, which is a piece of sample data, in this case a Customer object.&nbsp; We have several \u201cit\u201d blocks, which document the expected results of the test case.&nbsp; An \u201cit\u201d block without a do\/end is a test case that is \u201cpending\u201d meaning the test hasn\u2019t been written yet.<\/p>\n\n\n\n<p>We \u201cexpect\u201d certain results, so each of the test cases has one or more expected results.&nbsp; There are expect matchers, which are documented here: <a href=\"https:\/\/relishapp.com\/rspec\/rspec-expectations\/docs\/built-in-matchers\">https:\/\/relishapp.com\/rspec\/rspec-expectations\/docs\/built-in-matchers<\/a><\/p>\n\n\n\n<h2>Run rspec Again<\/h2>\n\n\n\n<p>Now the customer_spec.rb tests will run.&nbsp; You will see that some results are printed out, indicating how many tests passed (green), failed (red), or are pending (yellow).<\/p>\n\n\n\n<p>Edit .\/app\/models\/customer.rb and comment out this line:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>validates :first_name, presence: true<\/code><\/pre>\n\n\n\n<p>Then save the file and run rspec again.&nbsp; You will see that a test fails.&nbsp; The model is not validating the presence of the first_name, and the test reports this.&nbsp; Edit customer.rb again, and uncomment the line.&nbsp; You will see that the test again passes.<\/p>\n\n\n\n<h2>Assignment: Complete the Customer Model Test<\/h2>\n\n\n\n<p>Now add to spec\/models\/customer_spec.rb.&nbsp; There are a number of \u201cit\u201d statements without do\/end blocks.&nbsp; Add them. Each block should set up a test using the subject, and should have an appropriate expect statement. Then run rspec again.&nbsp; You should get all tests to pass, without any pending tests.<\/p>\n\n\n\n<h2>Request Testing<\/h2>\n\n\n\n<p>For request testing, we will use FactoryBot.&nbsp; This acts as a factory for sample data.&nbsp; We will also use Faker.&nbsp; This gem generates plausible values for sample data.&nbsp; Let\u2019s start with the factory.&nbsp; Edit the file .\/spec\/factories\/customers.rb so that it reads as follows:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'faker'\nFactoryBot.define do\n  factory :customer do |f|\n    f.first_name { Faker::Name.first_name }\n    f.last_name { Faker::Name.last_name }\n    f.phone { Faker::Number.number(digits: 10) }\n    f.email { Faker::Internet.email }\n  end\nend\n<\/code><\/pre>\n\n\n\n<p>This provides a means of generating as many sample customer entries as we want.<\/p>\n\n\n\n<h2>Editing .\/spec\/requests\/customers_spec.rb<\/h2>\n\n\n\n<p>Copy the following code into the file:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>require 'rails_helper'\nRSpec.describe \"CustomersControllers\", type: :request do\n  describe \"get customers_path\" do\n    it \"renders the index view\" do\n      FactoryBot.create_list(:customer, 10)\n      get customers_path\n      expect(response).to render_template(:index)\n    end\n  end\n  describe \"get customer_path\" do\n    it \"renders the :show template\" do\n      customer = FactoryBot.create(:customer)\n      get customer_path(id: customer.id)\n      expect(response).to render_template(:show)\n    end\n    it \"redirects to the index path if the customer id is invalid\" do\n      get customer_path(id: 5000) #an ID that doesn't exist\n      expect(response).to redirect_to customers_path\n    end\n  end\ndescribe \"get new_customer_path\" do\n    it \"renders the :new template\"\n  end\n  describe \"get edit_customer_path\" do\n    it \"renders the :edit template\"\n  end\n  describe \"post customers_path with valid data\" do\n    it \"saves a new entry and redirects to the show path for the entry\" do\n      customer_attributes = FactoryBot.attributes_for(:customer)\n      expect { post customers_path, params: {customer: customer_attributes}\n    }.to change(Customer, :count)\n      expect(response).to redirect_to customer_path(id: Customer.last.id)\n    end\n  end\n  describe \"post customers_path with invalid data\" do\n    it \"does not save a new entry or redirect\" do\n      customer_attributes = FactoryBot.attributes_for(:customer)\n      customer_attributes.delete(:first_name)\n      expect { post customers_path, params: {customer: customer_attributes}\n    }.to_not change(Customer, :count)\n      expect(response).to render_template(:new)\n    end\n  end\n  describe \"put customer_path with valid data\" do\n    it \"updates an entry and redirects to the show path for the customer\"\n  end\n  describe \"put customer_path with invalid data\" do\n    it \"does not update the customer record or redirect\"\n  end\n  describe \"delete a customer record\" do\n    it \"deletes a customer record\"\n  end\nend\n<\/code><\/pre>\n\n\n\n<h2>Now Run rspec Again<\/h2>\n\n\n\n<p>You will find that there are more tests, all passing (green), with some pending (yellow).&nbsp; If you look at the code you will see several new types of expect matchers.&nbsp; A post of valid data should change the number of Customer records, and should result in a redirect to a particular path.&nbsp; A post of invalid data should not change the number of customer records, and should not result in a render, not a redirect.&nbsp; The HTTP status code for a render is 200 meaning OK.  You can check the status code by checking response.status.&nbsp; <\/p>\n\n\n\n<p>For post and put requests, you must test both valid and invalid data to make sure both paths through the code work.<\/p>\n\n\n\n<p>Edit .\/app\/controllers\/customers_controller.rb . Comment out the line that starts with rescue_from and run rspec again.&nbsp; You will find that there is a test failure.&nbsp; So, that rescue_from line is needed.&nbsp; Uncomment it.<\/p>\n\n\n\n<h2>What Are We Testing?<\/h2>\n\n\n\n<p>Request testing tests each of the routes you have specified in config\/routes.rb.  You can see those routes by typing:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>bin\/rails routes<\/code><\/pre>\n\n\n\n<p>Request testing tests each of the methods you have in the controller, which methods pointed to by the routes.  To know what the test should do, you can look at the code in the controller (except that, in test driven development, you create the tests before you create the controller).<\/p>\n\n\n\n<h2>Tips on Request Testing<\/h2>\n\n\n\n<p>To test the edit, put, and delete routes, you need to specify a route to an existing entry.  So, you have to create that entry first.  You use the factory.  Then you pass the id of the customer entry you create to the path.  A put request is used to update an entry.  So, here is an example of a test of a put request with invalid data:<\/p>\n\n\n\n<pre class=\"wp-block-code\"><code>  describe \"put customer_path with invalid data\" do\n    it \"does not update the customer record or redirect\"\n do\n      customer = FactoryBot.create(:customer)\n      put customer_path(customer.id), params: {customer: {phone: \"123\"}}\n      customer.reload\n      expect(customer.phone).not_to eq(\"123\")\n      expect(response).to render_template(:edit) \n    end\n  end\n<\/code><\/pre>\n\n\n\n<p>Note the use of customer.reload.  The operation is attempting to change the database.  It will not change the copy of the customer object you have in memory.  You need to do the reload to copy values from the database into the customer object in memory.  In this case, the database value is not supposed to change, because the data is invalid.<\/p>\n\n\n\n<h2>Assignment Part 2<\/h2>\n\n\n\n<p>Add to spec\/requests\/customers_spec.rb so as to complete the pending test cases, those being the \u201cit\u201d blocks with do\/end or expect statements.<\/p>\n\n\n\n<p>Then push your work to github.  When you are all done, create the pull request for this assignment.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Testing validates that the application does what it is supposed to do.&nbsp; Also, applications change over time as new features are added.&nbsp; It is very easy to break an application by making changes.&nbsp; Automated testing can ensure that such breaks are rare. Often, the tests are written before the application code.&nbsp; This is called test<\/p>\n","protected":false},"author":5,"featured_media":0,"parent":0,"menu_order":0,"comment_status":"closed","ping_status":"closed","template":"","meta":{"_genesis_hide_title":false,"_genesis_hide_breadcrumbs":false,"_genesis_hide_singular_image":false,"_genesis_hide_footer_widgets":false,"_genesis_custom_body_class":"","_genesis_custom_post_class":"","_genesis_layout":"","_vp_format_video_url":"","_vp_image_focal_point":[]},"featured_image_src":null,"featured_image_src_square":null,"_links":{"self":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/801"}],"collection":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages"}],"about":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/types\/page"}],"author":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/users\/5"}],"replies":[{"embeddable":true,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/comments?post=801"}],"version-history":[{"count":0,"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/pages\/801\/revisions"}],"wp:attachment":[{"href":"https:\/\/learn.codethedream.org\/wp-json\/wp\/v2\/media?parent=801"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}